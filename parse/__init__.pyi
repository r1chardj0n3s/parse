from _typeshed import Incomplete
from datetime import tzinfo
from typing import Generic, Literal, TypeVar, overload


__all__ = ['parse', 'search', 'findall', 'with_pattern']


def with_pattern(pattern, regex_group_count=None): ...


class int_convert:
	CHARS: str
	base: Incomplete

	def __init__(self, base=None) -> None: ...
	def __call__(self, string, match): ...


class convert_first:
	converter: Incomplete

	def __init__(self, converter) -> None: ...
	def __call__(self, string, match): ...


class FixedTzOffset(tzinfo):
	ZERO: Incomplete

	def __init__(self, offset, name) -> None: ...
	def utcoffset(self, dt): ...
	def tzname(self, dt): ...
	def dst(self, dt): ...
	def __eq__(self, other): ...


class TooManyFields(ValueError): ...
class RepeatedNameError(ValueError): ...


class Parser:
	def __init__(self, format, extra_types=None, case_sensitive: bool = False) -> None: ...

	@property
	def named_fields(self): ...

	@property
	def fixed_fields(self): ...

	@property
	def format(self): ...

	@overload
	def parse(self, string: str, evaluate_result: Literal[True] = True) -> Result | None: ...
	@overload
	def parse(self, string: str, *, evaluate_result: Literal[False]) -> Match | None: ...
	@overload
	def parse(self, string: str, evaluate_result: Literal[False]) -> Match | None: ...

	@overload
	def search(self, string, pos: int = 0, endpos=None, evaluate_result: Literal[True] = True) -> Result | None: ...
	@overload
	def search(self, string, pos: int = 0, endpos=None, *, evaluate_result: Literal[False]) -> Match | None: ...
	@overload
	def search(self, string, pos, endpos, evaluate_result: Literal[False]) -> Match | None: ...

	@overload
	def findall(self, string, pos: int = 0, endpos=None, extra_types=None, evaluate_result: Literal[True] = True) -> ResultIterator[Result]: ...
	@overload
	def findall(self, string, pos: int = 0, endpos=None, extra_types=None, *, evaluate_result: Literal[False]) -> ResultIterator[Match]: ...
	@overload
	def findall(self, string, pos, endpos, extra_types, evaluate_result: Literal[False]) -> ResultIterator[Match]: ...

	def evaluate_result(self, m): ...


class Result:
	fixed: Incomplete
	named: Incomplete
	spans: Incomplete

	def __init__(self, fixed, named, spans) -> None: ...
	def __getitem__(self, item): ...
	def __contains__(self, name) -> bool: ...


class Match:
	parser: Incomplete
	match: Incomplete

	def __init__(self, parser, match) -> None: ...
	def evaluate_result(self): ...


_T = TypeVar('_T', bound='Result' | 'Match')


class ResultIterator(Generic[_T]):
	parser: Incomplete
	string: Incomplete
	pos: Incomplete
	endpos: Incomplete
	evaluate_result: Incomplete

	def __init__(self, parser, string, pos, endpos, evaluate_result: bool = True) -> None: ...
	def __iter__(self): ...
	def __next__(self) -> _T: ...
	next = __next__


@overload
def parse(format: str, string: str, extra_types=..., evaluate_result: Literal[True] = True, case_sensitive: bool = ...) -> Result | None: ...
@overload
def parse(format: str, string: str, extra_types=..., *, evaluate_result: Literal[False], case_sensitive: bool = ...) -> Match | None: ...
@overload
def parse(format: str, string: str, extra_types, evaluate_result: Literal[False], case_sensitive: bool = ...) -> Match | None: ...


@overload
def search(format: str, string: str, pos: int = 0, endpos: int | None = None, extra_types=None, evaluate_result: Literal[True] = True, case_sensitive: bool = False) -> Result | None: ...
@overload
def search(format: str, string: str, pos: int = 0, endpos: int | None = None, extra_types=None, *, evaluate_result: Literal[False], case_sensitive: bool = False) -> Match | None: ...
@overload
def search(format: str, string: str, pos: int, endpos: int | None, extra_types, evaluate_result: Literal[False], case_sensitive: bool = False) -> Match | None: ...


def findall(format, string, pos: int = 0, endpos=None, extra_types=None, evaluate_result: bool = True, case_sensitive: bool = False): ...
